# This is meant to be ran to add essentially "homemade" cmdlets that you can call on easily to do various tasks (mostly in AD) to automate easy things.

# Get-ADPasswordReset will reset a single users AD password to a specified password
# Get-ADPasswordResetBulk will reset a .csv file of a bulk amount of users to a specified password
# Get-ADPasswordResetBulkComplex will reset a .csv file of a bulk amount of users to a random complex password
# Get-ADGroupCompare will compare 2 AD user accounts and note similar and different group membership
# Get-ADLockoutCheck will check locked AD account and other lockout properties

# No profile or unsure? Uncomment following command and run it on Powershell and if not it will create a new profile.

#if (!(Test-Path -Path $PROFILE)) {
  New-Item -ItemType File -Path $PROFILE -Force
#}



# Start of the ADPasswordReset function

function Get-ADPasswordReset

{


$samAccountName = Read-Host -Prompt "Enter AD Account Name for Password Reset Here"

#Warning confirmation on the change, Y/N to confirm
 
Write-Warning "Confirm the information is correct before proceeding, this is a single password reset" -WarningAction Inquire

# Forced to input AD account name that needs a reset

$newPassword = ConvertTo-SecureString -AsPlainText "Password" -Force

# Password change to the new password specified

Set-ADAccountPassword -Identity $samAccountName -NewPassword $newPassword -Reset

# Calls on the new password listed above

Set-AdUser -Identity $samAccountName -ChangePasswordAtLogon $true

# Forces user to change password at next login

Write-Host " AD Password has been reset for: "$samAccountName

# Writes to PS window stating the changes took affect

}

# Start of the ADPasswordResetBulk function

function Get-ADPasswordResetBulkComplex

{

# Import System.Web assembly

Add-Type -AssemblyName System.Web

# Generate random password with defined complex requirements

[System.Web.Security.Membership]::GeneratePassword(11,2)
Function GenerateStrongPassword ([Parameter(Mandatory=$true)][int]$PasswordLenght)
{
Add-Type -AssemblyName System.Web
$PassComplexCheck = $false
do {
$newPassword=[System.Web.Security.Membership]::GeneratePassword($PasswordLenght,1)
If ( ($newPassword -cmatch "[A-Z\p{Lu}\s]") `
-and ($newPassword -cmatch "[a-z\p{Ll}\s]") `
-and ($newPassword -match "[\d]") `
-and ($newPassword -match "[^\w]")
)
{
$PassComplexCheck=$True
}
} While ($PassComplexCheck -eq $false)
return $newPassword
}

# User prompt to specify directory for the .csv file that has the list of users with a password reset needed. You NEED to pass the full directory and include file name or you will get Access is not enabled.

$csvDir = Read-Host -Prompt "Please enter the directory where the .csv file is"

# User prompt to 

Import-Csv "$csvDir" | ForEach-Object {

#Import from .csv file

$samAccountName = $_."samAccountName"

#Un-comment the below line if your CSV file includes password for all users

#$newPassword = ConvertTo-SecureString -AsPlainText $_."Password"  -Force

# Warning confirmation on the change, Y/N to confirm

Write-Warning "Confirm the information is correct before proceeding, this is a bulk complex password reset" -WarningAction Inquire

Set-ADAccountPassword -Identity $samAccountName -NewPassword $newPassword -Reset

# Calls on the new password listed above.

Set-AdUser -Identity $samAccountName -ChangePasswordAtLogon $true

# Forces user to change password at next login.

Write-Host " AD Password has been reset for: "$samAccountName

# Writes to PS window stating the changes took affect.

            }
        }

# Start of the ADPasswordResetBulkComplex function

function Get-ADPasswordResetBulkComplex

{

# Import System.Web assembly

Add-Type -AssemblyName System.Web

# Generate random password with defined complex requirements

[System.Web.Security.Membership]::GeneratePassword(11,2)
Function GenerateStrongPassword ([Parameter(Mandatory=$true)][int]$PasswordLenght)
{
Add-Type -AssemblyName System.Web
$PassComplexCheck = $false
do {
$newPassword=[System.Web.Security.Membership]::GeneratePassword($PasswordLenght,1)
If ( ($newPassword -cmatch "[A-Z\p{Lu}\s]") `
-and ($newPassword -cmatch "[a-z\p{Ll}\s]") `
-and ($newPassword -match "[\d]") `
-and ($newPassword -match "[^\w]")
)
{
$PassComplexCheck=$True
}
} While ($PassComplexCheck -eq $false)
return $newPassword
}

# User prompt to specify directory for the .csv file that has the list of users with a password reset needed. You NEED to pass the full directory and include file name or you will get Access is not enabled.

$csvDir = Read-Host -Prompt "Please enter the directory where the .csv file is"

# User prompt to 

Import-Csv "$csvDir" | ForEach-Object {

#Import from .csv file

$samAccountName = $_."samAccountName"

#Un-comment the below line if your CSV file includes password for all users

#$newPassword = ConvertTo-SecureString -AsPlainText $_."Password"  -Force

# Warning confirmation on the change, Y/N to confirm

Write-Warning "Confirm the information is correct before proceeding, this is a bulk complex password reset" -WarningAction Inquire

Set-ADAccountPassword -Identity $samAccountName -NewPassword $newPassword -Reset

# Calls on the new password listed above.

Set-AdUser -Identity $samAccountName -ChangePasswordAtLogon $true

# Forces user to change password at next login.

Write-Host " AD Password has been reset for: "$samAccountName

# Writes to PS window stating the changes took affect.

            }
        }

# Start of the Get-ADLockoutCheck function		

function Get-ADLockoutCheck

{

$samAccountName = Read-Host -Prompt "Enter AD Account Name Here

# Input username to specify the variable

Get-ADUser $samAccountName -Properties AccountLockoutTime,LastBadPasswordAttempt,BadPwdCount,LockedOut

# Checks last bad password attempts and locked out and duration of lockout as well

Get-ADUser -Identity $samAccountName -Properties PasswordLastSet | ft Name, PasswordLastSet

# Check when password was last set, gives date and time

Get-ADUser -Identity $samAccountName -Properties LastLogon | Select Name, @{Name='LastLogon';Expression={[DateTime]::FromFileTime($_.LastLogon)}}

# Checks to see when they logged in last

}

# Start of Get-ADGroupCompare function

function Get-ADGroupCompare
{

Write-Host "Compares 2 AD user accounts for group membership" -ForegroundColor Magenta

# Text notifying what this script does 

$Identity1 = $input = $(Write-Host "Please enter AD User 1" -NoNewLine) + $(Write-Host " EX: John.Smith " -ForegroundColor Green -NoNewLine; Read-Host)

# Text asking for AD User 1 to declare variable

$Identity2 = $input = $(Write-Host "Please enter AD User 2" -NoNewLine) + $(Write-Host " EX: Jacob.Ryan " -ForegroundColor Red -NoNewLine; Read-Host)

# Text asking for AD User 2 to declare variable

    $user1 = (Get-ADPrincipalGroupMembership -Identity $Identity1 | select Name | Sort-Object -Property Name).Name
    Write-Verbose ($user1 -join "; ")

# $Identity1 specified earlier will specify the identity and select the specific property. Declares $user1 variable

    $user2 = (Get-ADPrincipalGroupMembership -Identity $Identity2 | select Name | Sort-Object -Property Name).Name
    Write-Verbose ""
    Write-Verbose ($user2 -join "; ")

# $Identity1 specified earlier will specify the identity and select the specific property. Declares $user2 variable

    $SameGroups = (Compare-Object $user1 $user2 -PassThru -IncludeEqual -ExcludeDifferent)

# Compare the objects and see what is different between the $user1 and $user2 declared earlier.

    Write-Verbose ""
    Write-Verbose ($SameGroups -join "; ")

# Compares identical groups

    $UniqueID1 = (Compare-Object $user1 $user2 -PassThru | where {$_.SideIndicator -eq "<="})
    Write-Verbose ""

# Passthrough <=

    Write-Verbose ($UniqueID1 -join "; ")
    $UniqueID2 = (Compare-Object $user1 $user2 -PassThru | where {$_.SideIndicator -eq "=>"})

# Passthrough =>

    Write-Verbose ""
    Write-Verbose ($UniqueID2 -join "; ")
    $ID1Name = (Get-ADUser -Identity $Identity1 | Select Name).Name
    Write-Verbose ""
    Write-Verbose ($ID1Name -join "; ")
    $ID2Name = (Get-ADUser -Identity $Identity2 | Select Name).Name
    Write-Verbose ""
    Write-Verbose ($ID2Name -join "; ")

    Write-Host "--------------------------------------------------------------------------" -ForegroundColor Magenta
    Write-Host "[$ID1Name] and [$ID2Name] have the following groups in common:"
    Write-Host "--------------------------------------------------------------------------" -ForegroundColor Magenta
    $SameGroups
    Write-Host ""

    Write-Host "--------------------------------------------------------------------------" -ForegroundColor Green
    Write-Host "The following groups are unique to [$ID1Name]:"
    Write-Host "--------------------------------------------------------------------------" -ForegroundColor Green
    $UniqueID1
    Write-Host ""
    Write-Host "--------------------------------------------------------------------------" -ForegroundColor Red
    Write-Host "The following groups are unique to [$ID2Name]:"
    Write-Host "--------------------------------------------------------------------------" -ForegroundColor Red
    $UniqueID2
}
